--  ---------------------------
--  Basics
--  ---------------------------

[case test_no_type]
import attr

@attr.s
class C:
    a = attr.ib()
    b = attr.ib(init=False, metadata={'foo': 1})

c = C(1)
reveal_type(c.a)  # E: Revealed type is 'Any'
reveal_type(C.a)  # E: Revealed type is 'Any'
reveal_type(c.b)  # E: Revealed type is 'Any'
reveal_type(C.b)  # E: Revealed type is 'Any'

[case test_type_arg]
import attr

@attr.s
class C(object):
    a = attr.ib(type=int)

c = C(1)
reveal_type(c.a)  # E: Revealed type is 'builtins.int*'
reveal_type(C.a)  # E: Revealed type is 'builtins.int*'

C("1")  # E: Argument 1 to "C" has incompatible type "str"; expected "int"
C(a="1")  # E: Argument 1 to "C" has incompatible type "str"; expected "int"
C(None)
C(a=None)
C(a=1)

[case test_type_annotations]
import attr

@attr.s
class C(object):
    a : int = attr.ib()

c = C(1)
reveal_type(c.a)  # E: Revealed type is 'builtins.int'
reveal_type(C.a)  # E: Revealed type is 'builtins.int'


--  ---------------------------
--  Defaults
--  ---------------------------

[case test_defaults_no_type]
import attr

a = attr.ib(default=0)
reveal_type(a)  # E: Revealed type is 'builtins.int*'

b = attr.ib(0)
reveal_type(b)  # E: Revealed type is 'builtins.int*'


[case test_defaults_type_arg]
import attr

a = attr.ib(type=int)
reveal_type(a)  # E: Revealed type is 'builtins.int*'

b = attr.ib(default=0, type=int)
reveal_type(b)  # E: Revealed type is 'builtins.int*'

c = attr.ib(default='bad', type=int)
# object, the common base of str and int:
reveal_type(c)  # E: Revealed type is 'builtins.object*'


[case test_defaults_type_annotations]
import attr

a: int = attr.ib()
reveal_type(a)  # E: Revealed type is 'builtins.int'

b: int = attr.ib(default=0)
reveal_type(b)  # E: Revealed type is 'builtins.int'

c: int = attr.ib(default=0, type=str)  # E: Incompatible types in assignment (expression has type "object", variable has type "int")


--  ---------------------------
--  Factory Defaults
--  ---------------------------

[case test_factory_defaults_type_arg]
import attr
from typing import List

a = attr.ib(type=List[int])
reveal_type(a)  # E: Revealed type is 'builtins.list*[builtins.int*]'

b = attr.ib(default=attr.Factory(list), type=List[int])
# FIXME: shouldn't the `default` type be upgraded from `list` to `List[int]``?  make a mypy github issue
reveal_type(b)  # E: Revealed type is 'builtins.object*'

c = attr.ib(default=attr.Factory(list), type=int)

# object, the common base of list and int:
reveal_type(c)  # E: Revealed type is 'builtins.object*'

def int_factory() -> int:
    return 0

d = attr.ib(default=attr.Factory(int_factory), type=int)
reveal_type(d)  # E: Revealed type is 'builtins.int*'


[case test_factory_defaults_type_annotations]
import attr
from typing import List

a: List[int] = attr.ib()
reveal_type(a)  # E: Revealed type is 'builtins.list[builtins.int]'

b: List[int] = attr.ib(default=attr.Factory(list), type=List[int])
reveal_type(b)  # E: Revealed type is 'builtins.list[builtins.int]'

c: List[int] = attr.ib(default=attr.Factory(list), type=str)  # E: Argument 2 has incompatible type "Type[str]"; expected "Type[List[int]]"

def int_factory() -> int:
    return 0

d: int = attr.ib(default=attr.Factory(int_factory))
reveal_type(d)  # E: Revealed type is 'builtins.int'


--  ---------------------------
--  Validators
--  ---------------------------

[case test_validators]
import attr
from attr.validators import in_, and_, instance_of
import enum

class State(enum.Enum):
    ON = "on"
    OFF = "off"

a = attr.ib(type=int, validator=in_([1, 2, 3]))
aa = attr.ib(validator=in_([1, 2, 3]))
b = attr.ib(type=int, validator=[in_([1, 2, 3]), instance_of(int)])
c = attr.ib(type=int, validator=(in_([1, 2, 3]), instance_of(int)))
d = attr.ib(type=int, validator=and_(in_([1, 2, 3]), instance_of(int)))
e = attr.ib(type=int, validator=1)  # E: No overload variant matches argument types [Overload(def (x: Union[builtins.str, builtins.bytes, typing.SupportsInt] =) -> builtins.int, def (x: Union[builtins.str, builtins.bytes], base: builtins.int) -> builtins.int), builtins.int]
f = attr.ib(type=State, validator=in_(State))
# mypy does not know how to get the contained type from an enum:
ff = attr.ib(validator=in_(State))  # E: Need type annotation for variable


[case test_init_with_validators]
import attr
from attr.validators import instance_of

@attr.s
class C:
    x = attr.ib(validator=instance_of(int))

reveal_type(C.x)  # E: Revealed type is 'builtins.int*'

C(42)
C(x=42)
C("42")  # E: Argument 1 to "C" has incompatible type "str"; expected "int"
C(None)


[case test_custom_validators]
import attr

def validate_int(inst, at, val: int):
    pass

def validate_str(inst, at, val: str):
    pass

a = attr.ib(type=int, validator=validate_int)  # int
b = attr.ib(type=int, validator=validate_str)  # E: Argument 2 has incompatible type "Callable[[Any, Any, str], Any]"; expected "Union[Callable[[Any, Attribute[Any], int], Any], List[Callable[[Any, Attribute[Any], int], Any]], Tuple[Callable[[Any, Attribute[Any], int], Any], ...]]"

reveal_type(a) # E: Revealed type is 'builtins.int'


--  ---------------------------
--  Make
--  ---------------------------

[case test_make_from_dict]
import attr
C = attr.make_class("C", {
    "x": attr.ib(type=int),
    "y": attr.ib()
})


[case test_make_from_str]
import attr
C = attr.make_class("C", ["x", "y"])


[case test_astuple]
import attr
@attr.s
class C:
    a: int = attr.ib()

t1 = attr.astuple(C)
reveal_type(t1)  # E: Revealed type is 'builtins.tuple[Any]'


[case test_asdict]
import attr
@attr.s
class C:
    a: int = attr.ib()

t1 = attr.asdict(C)
reveal_type(t1)  # E: Revealed type is 'builtins.dict[builtins.str, Any]'
